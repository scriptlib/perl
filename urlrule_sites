#!/usr/bin/perl -w
use strict;
use File::Spec::Functions qw/catfile/;
use Getopt::Long;
use MyPlace::URLRule::SimpleQuery;


my $DEFAULT_HOST = "weibo.com,weipai.cn,vlook.cn,google.search.image";
my $DB_EXT = ".DB";
my $ID_EXT = ".ID";
my $ENCODING = "utf8";
#binmode STDOUT,$ENCODING;
#binmode STDERR,$ENCODING;
my @OPTIONS = qw/
		help|h
		manual|man
		list|l
		debug|d
		hosts|sites:s
		command|c:s
		update|u
		add|a
		additem
		saveurl=s
		overwrite|o
	/;
my %OPTS;
GetOptions(\%OPTS,@OPTIONS);


sub process_command {
	my $cmd = shift;
	my $target = shift;
	if($cmd eq 'LIST') {
		my $idx = 1;
		foreach my $name(keys %{$target}) {
			next unless($target->{$name});
			print STDERR "[" . uc($name),"]:\n";
			foreach my $item(@{$target->{$name}}) {
				printf "\t[%03d] %-20s [%d]  %s\n",$idx,$item->[2],$item->[3],$item->[1];
				$idx++;
			}
		}
		return 0;
	}
	elsif(($cmd eq 'UPDATE') or ($cmd eq 'SAVE')) {
		use MyPlace::URLRule::OO;
		my @request;
		my $count = 0;
		foreach my $name(keys %{$target}) {
			next unless($target->{$name});
			foreach my $item(@{$target->{$name}}) {
				next unless($item && @{$item});
				push @request,{
					count=>1,
					level=>$item->[3],
					url=>$item->[2],
					title=>$item->[1] . "/$name/",
				};
				$count++;
			}
		}
		my $idx = 0;
		my $URLRULE = new MyPlace::URLRule::OO('action'=>$cmd);
		foreach(@request) {
			$idx++;
			$_->{progress} = "[$idx/$count]";
			$URLRULE->autoApply($_);
			$URLRULE->reset();
		}
		if($URLRULE->{DATAS_COUNT}) {
			return 0;
		}
		else {
			return 2;
		}
	}
}
my @NAMES = @ARGV;
#if(!@NAMES) {
#	print STDERR "Reading names from STDIN ...\n";
#	while(<STDIN>) {
#		chomp;
#		push @NAMES,$_;
#	}
#	print STDERR scalar(@NAMES) . " names read.\n";
#}
my $COMMAND = $OPTS{additem} ? 'ADDITEM' : $OPTS{add} ? 'ADD' : $OPTS{list} ? 'LIST' : $OPTS{update} ? 'UPDATE' : $OPTS{command} ? uc($OPTS{command}) : 'UPDATE';

$COMMAND = "SAVEURL" if($OPTS{saveurl});

my $HOSTSNAME = $OPTS{hosts} || $DEFAULT_HOST;
my @HOSTS = split(/\s*,\s*/,$HOSTSNAME);

#print STDERR "$COMMAND ",join(", ",@NAMES), " [",join(", ",@HOSTS),"]\n";
if($COMMAND eq 'ADD' || $COMMAND eq 'ADDITEM') {
	my $r = 0;
	if(!@NAMES) {
		print STDERR "Arguments requried for COMMAND <add>\n";
		$r = 3;
	}
	else {
		foreach my $host (@HOSTS) {
			my $SQ;
			if($OPTS{overwrite}) {
				$SQ = MyPlace::URLRule::SimpleQuery->new([$host,'overwrite']);
			}
			else {
				$SQ = MyPlace::URLRule::SimpleQuery->new($host);
			}
			my ($count,$msg);
			if($COMMAND eq 'ADD') {
				($count,$msg) = $SQ->add(@NAMES);
			}
			else {
				($count,$msg) = $SQ->additem(@NAMES);
			}
			#print STDERR "SimpleQuery Add ",join(", ",$count,$msg),"\n";
			if($count) {
				$SQ->save;
			}
			else {
				$r = 2;
			}
		}
	}
	exit $r;
}
elsif($COMMAND eq '_UPGRADE') {
	if(!@NAMES) {
		print STDERR "Arguments requried for COMMAND <_UPGRADE>\n";
		exit 3;
	}
	my $SRCD = $OPTS{srcd} || ".";
	my $DSTD = $OPTS{dstd} || "_upgrade";
	foreach my $host (@HOSTS) {
		my $SQ = MyPlace::URLRule::SimpleQuery->new($host);
		foreach(@NAMES) {
			my($id,$name) = $SQ->item($_);
			if($id and $name) {
				my $src = catfile($SRCD,$_);
				my $dstd = catfile($DSTD,"$_/$host");
				print STDERR "\"$src\" => \"$dstd/$id\"\n";
				system('mkdir','-p','--',$dstd) unless(-d $dstd);
				system('mv','-v','--',$src,catfile($dstd,$id));
				print STDERR "\n";
			}
			else {
				print STDERR "Id not found for \"$_\"\n";
			}
		}
	}
	exit 0;
}
elsif($COMMAND eq 'SAVEURL') {
		my $SQ = MyPlace::URLRule::SimpleQuery->new($HOSTSNAME);
		my($id,$name) = $SQ->item(@NAMES);
		if(!$id) {
			print STDERR "Error: ",$name,"\n";
			exit 3;
		}
		use MyPlace::URLRule::OO;
		my $URLRULE = new MyPlace::URLRule::OO('action'=>'SAVE');
		$URLRULE->autoApply({
				count=>1,
				level=>0,
				url=>$OPTS{saveurl},
				title=>join("/",$name,$HOSTSNAME,$id),
		});
		if($URLRULE->{DATAS_COUNT}) {
			exit 0;
		}
		else {
			exit 2;
		}
}

my %target;
foreach my $host (@HOSTS) {
	my $SQ = new MyPlace::URLRule::SimpleQuery($host);
	$target{$host} = [];
	if(!@NAMES) {
		my($status,@result) = $SQ->all();
		if(!$status) {
			print STDERR "[$host] Error: ",@result,"\n";
		}
		else {
			push @{$target{$host}},@result;
		}
	}
	else {
		foreach my $keyword (@NAMES) {
			my($status,@result) = $SQ->query($keyword);
			if(!$status) {
				print STDERR "[$host] Error: ",@result,"\n";
			}
			else {
				push @{$target{$host}},@result;
			}
		}
	}
	$SQ = undef;
}
exit process_command($COMMAND,\%target);

__END__

#       vim:filetype=perl
