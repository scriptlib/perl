#!/usr/bin/perl -w 
###APPNAME:     renameext
###APPAUTHOR:   eotect
###APPDATE:	Sun Mar 30 12:46:15 2008
###APPVER:	0.1
###APPDESC:	rename files using perl regexp
###APPUSAGE:	[options] (pattern|func) (files...) 
###APPEXAMPLE:	renameext -t 's/^.*(\d+)\.jpg/$1' *\n\trenameext -t 'ucfirst' *
###APPOPTION:	--test, -t:Test mode on|--rule,-r:Use internal rule|--swap, -sw:Swap mode on|--no-dot,-nd:Replace dots|--force,-f:Override exists files
use strict;
$ARGV[0]="-h" unless(@ARGV);
use lib $ENV{XR_PERL_MODULE_DIR};

use utf8;
use Encode;
use Getopt::Long;
use MyPlace::Script::Usage qw/exit_usage/;

my %OPTS;
my @OPTIONS= qw/
	help|h|?
	test|t
	swap|sw:s
	force|f
	verbose|v
	debug
	rule|r:s
	dir|d:s
	delete
/;
GetOptions(\%OPTS,@OPTIONS);
exit_usage(0,$0) if($OPTS{'help'});

my $utf8 = find_encoding("utf8");
my @OLDARGV = @ARGV;
@ARGV = ();
foreach(@OLDARGV) {
    push @ARGV,$_;
}
#binmode STDERR,'utf8';
#binmode STDOUT,'utf8';
#binmode STDIN,'utf8';

sub strnum {
	my $val = shift;
	my $numlen = shift(@_) || 0;
	return $val if($numlen<2);
	return $val if($val >= (10**$numlen));
	my $str = "0"x$numlen . $val;
	return substr($str,length($str) - $numlen);
}

my $INTPOOL=1;

my %RULES = (
	'autonumber'=>sub {
		my $old = shift;
		my $new = $old;
		my $ext = '';
		my $prefix = '';
		if($new =~ m/^(.+)\/(.+)$/) {
			$prefix = $1;
			$new = $2;
		}
		if($new =~ m/\.([^\.\\\/]+)$/) {
			$ext = ".$1";
		}
		return $old if($new =~ m/\d\d\d\d\d\d\d\d$ext$/);
		my $filename = $prefix . strnum($INTPOOL,8) . $ext;
		while(-e $filename) {
			$INTPOOL++;
			$filename = $prefix . strnum($INTPOOL,8) . $ext;
		}
		return $filename;
	},
	cleanbegin1=>'s/(^|[\/\\\\])\s*(?:【.+?】|（.+?）)\s*/$1/',
	cleanend1=>'s/[_\s]*【?\d+[Pp]】?\s*$//',
	dotless=>'s/\.(?=.*\.)/ /g',
	trim=>'s/^\s+|[\.\s]+$|(?<=\/)\s+|[\.\s]+(?=\/)//g',
	noemoji=>'s/[\p{Emoticons}]+//g',
	#cjk=>'s/[^\p{CJK_Symbols_And_Punctuation}\p{CJK_Unified_Ideographs}\p{ASCII}]+//g',
	cjk=>'s/[^{\p{Punctuation}\p{CJK_Unified_Ideographs}\p{CJK_SYMBOLS_AND_PUNCTUATION}\p{HALFWIDTH_AND_FULLWIDTH_FORMS}\p{CJK_COMPATIBILITY_FORMS}\p{VERTICAL_FORMS}\p{ASCII}\p{LATIN}\p{CJK_Unified_Ideographs_Extension_A}\p{CJK_Unified_Ideographs_Extension_B}\p{CJK_Unified_Ideographs_Extension_C}\p{CJK_Unified_Ideographs_Extension_D}]//g',
	
);

my $exp;

if(defined $OPTS{rule}) {
	if($OPTS{rule} && defined $RULES{$OPTS{rule}}) {
		print STDERR "[RenameEXT] Rule => \"$OPTS{rule}\"\n";
		$exp = $RULES{$OPTS{rule}};
	}
	elsif($OPTS{rule}) {
		print STDERR "Error, rule \"$OPTS{rule}\" not defined.\n";
		exit 1;
	}
	else {
		print STDERR "Defined rules are:\n";
		foreach (keys %RULES) {
			print STDERR sprintf("%-12s: %s\n",$_ ,ref $RULES{$_} ? "{CODES}" : $RULES{$_}); 
		}
		exit 2;
	}
}
elsif(defined $OPTS{swap}) {
	if($OPTS{swap}) {
		$exp = "s/^([^$OPTS{swap}]+?)(\\s*)$OPTS{swap}(\\s*)(.+)\.([^.]+)\$/\$4\$3$OPTS{swap}\$2\$1.\$5/";
	}
	else {
		$exp = "s/^([^-]+?)\\s*-\\s*(.+)\\.([^.]+)\$/\$2 - \$1.\$3/";
	}
	
}
else {
	$exp = shift;
}

my $RENAMER;



if(ref $exp) {
	$RENAMER = $exp;
	print STDERR "[RenameEXT] Exp => <REF>\n";
}
elsif($exp =~ /\/.*\//) {
	print STDERR "[RenameEXT] Exp => \"$exp\"\n";
	$RENAMER = sub    {
            my $r = shift;
			$_ = $r;
			$! = undef;
			$@ = undef;
			eval($exp);
			print STDERR "$!$@\n" if($! or $@);
            return $_;
   };
}
else {
	print STDERR "[RenameEXT] Exp => \"$exp\"\n";
	$RENAMER = sub {
		my $r = shift;
		$_ = $r;
		$r = eval($exp);
		return $r;
	}
}

use Data::Dumper;
#print Dumper($RENAMER);

die("Error: $@\n") if($@);

my $tempname = 0;
while(-e $tempname) {
    $tempname ++;
}
sub my_rename {
    my ($old,$new)=@_;
	if($OPTS{delete}) {
		unlink $old or return undef;
		return 1;
	}
    rename $old,"$tempname" or return undef;
    rename "$tempname",$new or return undef;
    return 1;
}

my @files;
if($OPTS{dir}) {
	die("Directory not accessiable: <$OPTS{dir}>\n") unless(-d $OPTS{dir});
	if(opendir(my $dh,$OPTS{dir})) {
		while(readdir($dh)) {
			next if($_ eq '.');
			next if($_ eq '..');
			#print STDERR $_,"\n";
			push @files,"$OPTS{dir}/$_";
		}
		close $dh;
	}
	else {
		print STDERR "Error opening directory <$OPTS{dir}>: $!\n";
	}
}
if(@ARGV) {
    push @files,@ARGV;
}

if($OPTS{dir}) {
	print STDERR "Nothing to do for directory: <$OPTS{dir}>\n" unless(@files);
}
elsif(!@files) {
    print STDERR "Please input filenames:\n" if($OPTS{verbose});
    while(<STDIN>) {
        chomp;
        push @files,$_;
    }
}


my $dfile=0;
foreach my $old(grep !/^\.\.?$/,@files) {
	print STDERR "$old\n" if($OPTS{'debug'});
	my $uold = $utf8->decode($old);
    my $unew = &$RENAMER($uold);
	my $new = $utf8->encode($unew);
    if($new eq $old) {
		print STDERR ("\"$old\" [Ignored]\n") if($OPTS{verbose});
        next;
    }
	$new =~ s/\/+$//;
	$old =~ s/\/+$//;
	if($OPTS{force} && -e $new) {
		print STDERR "[FORCE] backup $new.\n";
		my $backup = $new . '.backup~';
		if($OPTS{test}) {
		    print STDERR ("\"$new\"\n\t->\"$backup\" (Test only) [Sucessed!]\n");
		}
		else {
			if(&my_rename($new,$backup)) {
		        print STDERR ("\"$new\"\n\t->\"$backup\" [Sucessed!]\n");
			}
	        else {
		        print STDERR ("\"$new\"\n\t->\"$backup\" [Failed:$!]\n");
			}
		}
	}
	if(-e $new) {
        $dfile++;
        print STDERR "[$dfile] \"$old\"\n\t->\"$new\" [Failed:File exists]\n";
        next;
    }
    if($OPTS{test}) {
        print STDERR ("\"$old\"\n\t->\"$new\" (Test only) [Sucessed!]\n");
    }
    else {
        if(&my_rename($old,$new)) {
            print STDERR ("\"$old\"\n\t->\"$new\" [Sucessed!]\n");
        }
        else {
            print STDERR ("\"$old\"\n\t->\"$new\" [Failed:$!]\n");
        }
    }
}
