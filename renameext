#!/usr/bin/perl -w 
###APPNAME:     renameext
###APPAUTHOR:   eotect
###APPDATE:	Sun Mar 30 12:46:15 2008
###APPVER:	0.1
###APPDESC:	rename files using perl regexp
###APPUSAGE:	[options] (pattern|func) (files...) 
###APPEXAMPLE:	renameext -t 's/^.*(\d+)\.jpg/$1' *\n\trenameext -t 'ucfirst' *
###APPOPTION:	--test, -t:Test mode on|--swap, -sw:Swap mode on|--no-dot,-nd:Replace dots|--force,-f:Override exists files
use strict;
$ARGV[0]="-h" unless(@ARGV);
use lib $ENV{XR_PERL_MODULE_DIR};

use utf8;
use Encode;
use Getopt::Long;
use MyPlace::Script::Usage qw/exit_usage/;

my %OPTS;
my @OPTIONS= qw/
	help|h|?
	test|t
	swap|sw:s
	force|f
	verbose|v
	debug
	rule|r:s
/;
GetOptions(\%OPTS,@OPTIONS);
exit_usage(0,$0) if($OPTS{'help'});

my $utf8 = find_encoding("utf8");
my @OLDARGV = @ARGV;
@ARGV = ();
foreach(@OLDARGV) {
    push @ARGV,$utf8->decode($_);
}
binmode STDERR,'utf8';
binmode STDOUT,'utf8';
binmode STDIN,'utf8';

sub strnum {
	my $val = shift;
	my $numlen = shift(@_) || 0;
	return $val if($numlen<2);
	return $val if($val >= (10**$numlen));
	my $str = "0"x$numlen . $val;
	return substr($str,length($str) - $numlen);
}

my $INTPOOL=1;

my %RULES = (
	'autonumber'=>sub {
		my $old = shift;
		my $new = $old;
		my $ext = '';
		my $prefix = '';
		if($new =~ m/^(.+)\/(.+)$/) {
			$prefix = $1;
			$new = $2;
		}
		if($new =~ m/\.([^\.\\\/]+)$/) {
			$ext = ".$1";
		}
		return $old if($new =~ m/\d\d\d\d\d\d\d\d$ext$/);
		my $filename = $prefix . strnum($INTPOOL,8) . $ext;
		while(-e $filename) {
			$INTPOOL++;
			$filename = $prefix . strnum($INTPOOL,8) . $ext;
		}
		return $filename;
	},
	cleanbegin1=>'s/(^|[\/\\\\])\s*(?:【.+?】|（.+?）)\s*/$1/',
	cleanend1=>'s/[_\s]*【?\d+[Pp]】?\s*$//',
	dotless=>'s/\.(?=.*\.)/ /g',
	trim=>'s/^\s+|[\.\s]+$|(?<=\/)\s+|[\.\s]+(?=\/)//g',
);

my $exp;

if(defined $OPTS{rule}) {
	if($OPTS{rule} && defined $RULES{$OPTS{rule}}) {
		print STDERR "Use internal rule $OPTS{rule}\n";
		$exp = $RULES{$OPTS{rule}};
	}
	elsif($OPTS{rule}) {
		print STDERR "Error, rule \"$OPTS{rule}\" not defined.\n";
		exit 1;
	}
	else {
		print STDERR "Defined rules are:\n";
		foreach (keys %RULES) {
			print STDERR sprintf("%-12s: %s\n",$_ ,ref $RULES{$_} ? "{CODES}" : $RULES{$_}); 
		}
		exit 2;
	}
}
elsif(defined $OPTS{swap}) {
	if($OPTS{swap}) {
		$exp = "s/^([^$OPTS{swap}]+?)(\\s*)$OPTS{swap}(\\s*)(.+)\.([^.]+)\$/\$4\$3$OPTS{swap}\$2\$1.\$5/";
	}
	else {
		$exp = "s/^([^-]+?)\\s*-\\s*(.+)\\.([^.]+)\$/\$2 - \$1.\$3/";
	}
	
}
else {
	$exp = shift;
}

my $RENAMER;

print STDERR ref $exp,"\n";
if(ref $exp) {
	$RENAMER = $exp;
}
elsif($exp =~ /\/.*\//) {
	$RENAMER = sub    {
            my $r = shift;
			$_ = $r;
			eval($exp);
            return $_;
   };
}
else {
	$RENAMER = sub {
		my $r = shift;
		$_ = $r;
		$r = eval($exp);
		return $r;
	}
}

use Data::Dumper;
print Dumper($RENAMER);

die("Error: $@\n") if($@);

my $tempname = 0;
while(-e $tempname) {
    $tempname ++;
}
sub my_rename {
    my ($old,$new)=@_;
    rename $old,"$tempname" or return undef;
    rename "$tempname",$new or return undef;
    return 1;
}

my @files;
if(@ARGV) {
    @files = @ARGV;
}
else {
    print STDERR "Please input filenames:\n" if($OPTS{verbose});
    while(<STDIN>) {
        chomp;
        push @files,$_;
    }
}


my $dfile=0;
foreach my $old(grep !/^\.\.?$/,@files) {
	print STDERR "$old\n" if($OPTS{'debug'});
    my $new = &$RENAMER($old);
    if($new eq $old) {
		print STDERR ("\"$old\" [Ignored]\n") if($OPTS{verbose});
        next;
    }
	$new =~ s/\/+$//;
	$old =~ s/\/+$//;
	if($OPTS{force} && -e $new) {
		print STDERR "[FORCE] backup $new.\n";
		my $backup = $new . '.backup~';
		if($OPTS{test}) {
		    print STDERR ("\"$new\"\n\t->\"$backup\" (Test only) [Sucessed!]\n");
		}
		else {
			if(&my_rename($new,$backup)) {
		        print STDERR ("\"$new\"\n\t->\"$backup\" [Sucessed!]\n");
			}
	        else {
		        print STDERR ("\"$new\"\n\t->\"$backup\" [Failed:$!]\n");
			}
		}
	}
	if(-e $new) {
        $dfile++;
        print STDERR "[$dfile] \"$old\"\n\t->\"$new\" [Failed:File exists]\n";
        next;
    }
    if($OPTS{test}) {
        print STDERR ("\"$old\"\n\t->\"$new\" (Test only) [Sucessed!]\n");
    }
    else {
        if(&my_rename($old,$new)) {
            print STDERR ("\"$old\"\n\t->\"$new\" [Sucessed!]\n");
        }
        else {
            print STDERR ("\"$old\"\n\t->\"$new\" [Failed:$!]\n");
        }
    }
}
