#!/usr/bin/perl -w 
use Cwd qw/getcwd/;
use lib $ENV{XR_PERL_MODULE_DIR};
use MyPlace::ReEnterable;
use MyPlace::Script::Message;
use MyPlace::URLRule::HostMap qw/%HOST_MAP get_task valid_hostname add_host get_hosts/;

our %NAMES= (
    'names'=> {
       'Megan Fox'             => {'megan-fox'=>[qw/skins.be celebscentral.net/]},
    },
);

use constant {
    TASK_FILE_RESUME => '.urlrule_task_resume',
    TASK_FILE_LOG    => 'urlrule_task.log',
};

my $TASK_LOGGING    = 1;
my $TASK_ACTION     = 'urlrule_get';
my $TASK_DATABASE   = "URLRule_Database.pl";
die("No DATA_FILE(" . $TASK_DATABASE . ") found\n") unless(-r $TASK_DATABASE);
do $TASK_DATABASE;
my $TASK_WORKDIR;
my $TASK_FILEHANDLE_LOG;


my %HOSTS = %MyPlace::URLRule::HostMap::HOST_MAP;
my @HOSTS = keys %HOSTS;
my @NAMES = keys %NAMES;

my %IDS;
foreach my $name(@NAMES) {
    my @keys = keys %{$NAMES{$name}};
    foreach(@keys) {
        $IDS{$_} = [] unless($IDS{$_});
        push @{$IDS{$_}},@{$NAMES{$name}->{$_}};
    }
}


my @IDS = keys %IDS;





sub info {
    require Data::Dumper;
    return Data::Dumper->Dump([\%HOSTS,\@HOSTS,\%NAMES,\@NAMES,\%IDS,\@IDS],[qw/%HOSTS @HOSTS %NAMES @NAMES %IDS @IDS/]);
}

sub build_task {
    my ($name,$id,$host)=@_;
    my $dst = "$name/$host";
    my ($url,$level) = &get_task($host,$id);
    return {NAME=>$name,HOST=>$host,URL=>$url,LEVEL=>$level,DEST=>$dst};
}

sub select_by_name {
    my $name  = shift;
    app_message "select_by_name: $name\n";
    my @result;
    foreach my $id (keys %{$NAMES{$name}}) {
        foreach my $host (@{$IDS{$id}}) {
            push @result,&build_task($name,$id,$host);
        }
    }
    return @result;
}

sub select_by_id {
    my $id = shift;
    my @result;
    app_message "select_by_id: $id\n";
    foreach my $name (@NAMES) {
        if($NAMES{$name}->{$id}) {
            foreach my $host(@{$NAMES{$name}->{$id}}) {
                push @result,&build_task($name,$id,$host);    
            }
        }
    }
    return @result;
}

sub select_by_host {
    my $host = shift;
    my @result;
    foreach my $name (@NAMES) {
        foreach my $id (keys %{$NAMES{$name}}) {
            foreach (@{$NAMES{$name}->{$id}}) {
                if($_ eq $host) {
                    push @result,&build_task($name,$id,$host);    
                }
            }
        }
    }
    return @result;
}

sub select {
    my $key =shift;
    my @result;
    my $tested=0;
    unless($key) {
        foreach(@NAMES) {
            push @result,select_by_name($_);
        }
        return @result;
    }
    foreach(@NAMES) {
        if($_ eq $key) {
            return select_by_name($_);
	}
    }
    foreach(@IDS) {
        if($_ eq $key) {
            return select_by_id($_);
	}
    }
    foreach(@HOSTS) {
        if($_ eq $key) {
            return select_by_host($_);
	}
    }
    foreach(@NAMES) {
        if($_ =~ /$key/) {
            $tested=1;
            push @result,select_by_name($_);
	}
    }
    return @result if($tested);
    foreach(@IDS) {
        if($_ =~ /$key/) {
            $tested=1;
            push @result,select_by_id($_);
	}
    }
    return @result if($tested);
    foreach(@HOSTS) {
        if($_ =~ /$key/) {
            push @result,select_by_host($_);
	}
    }
    return @result;;
}

sub log {
    return unless($TASK_FILEHANDLE_LOG);
    print $TASK_FILEHANDLE_LOG scalar(localtime),": ",@_,"\n" if(@_);
}

sub run {
    my ($dest,$url,$level) = @_;
    my $TASK_WORKDIR = getcwd;
    system("mkdir","-vp",$dest) unless(-d $dest);
    if(chdir $dest) {
        &log("Task start: " . $TASK_ACTION  . " $url $level");
        system($TASK_ACTION,$url,$level);
        &log("Task completed: " . $TASK_ACTION . " $url $level");
    }
    else {
        &log("Task error: Can't not access \"$dest\"");
        app_error "Can't not access \"$dest\"\n";
    }
    chdir $TASK_WORKDIR;
}

sub start {
    my $hnd = shift @_;
    unshift @_,$hnd if($hnd and (!ref $hnd));
    my @tasks;
    my %tasks;
    if(!@_) {
        push @tasks,&select();
    }
    else {
        foreach(@_) {
            push @tasks,&select($_);
        }
    }
    foreach(@tasks) {
        $tasks{$_->{URL}}=$_ if($_);
    }
    foreach my $task(values %tasks) {
        next unless($task);
        if(ref $hnd) {
            $hnd->push(undef,"run",$task->{DEST},$task->{URL},$task->{LEVEL});
        }
        else {
            &run($task->{DEST},$task->{URL},$task->{LEVEL});
        }
    }
}

sub sig_killed {
    app_message("saving remained tasks...\n");
    if($phnd->{lastStack}) {
        $phnd->unshift(@{$phnd->{lastStack}});
    }
    chdir($TASK_WORKDIR) if($TASK_WORKDIR);
    $phnd->saveToFile(TASK_FILE_RESUME);
    app_message($phnd->length," tasks saved to TASK_FILE_RESUME\n");
    &log("Updating aborted!");
    close TASK_FILEHANDLE_LOG;
    exit 1;
}



$SIG{INT} = \&sig_killed;
my $phnd;

sub init {
        open $TASK_FILEHANDLE_LOG,">>",TASK_FILE_LOG;
        $phnd= MyPlace::ReEnterable->new('main');
};


$TASK_WORKDIR = getcwd();


if(@ARGV) {
    my $first = shift @ARGV;
    if($first eq 'TEST') {
        $TASK_ACTION='echo';
        &start(@ARGV); 
        exit 0;
    }
    else {
        unshift @ARGV,$first;
        &init;
        &log("Updating start: ",join(" ",@ARGV));
        &start($phnd,@ARGV);
    }
}
else {
    &init;
    $phnd->loadFromFile(TASK_FILE_RESUME);
    if($phnd->length) {
        &log("Updating resumed");
    }
    else {
        &log("Updating start: [All]");
        &start($phnd);
    }
}
while(my $tasks = $phnd->length) {
    app_error("[$tasks] tasks remained\n");
    $phnd->run();
}
app_message "All tasks completed.\n";
unlink TASK_FILE_RESUME if(-f TASK_FILE_RESUME);
&log("Updating completed.");
close TASK_FILEHANDLE_LOG;
exit 0;
