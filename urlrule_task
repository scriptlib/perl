#!/usr/bin/perl -w 
use Cwd qw/getcwd/;
use lib $ENV{XR_PERL_MODULE_DIR};
use MyPlace::URLRule;
use MyPlace::ReEnterable;
use MyPlace::Script::Message;
use strict;

#use MyPlace::URLRule::HostMap qw/%HOST_MAP get_task valid_hostname add_host get_hosts/;

my $phnd;
use constant {
    TASK_FILE_RESUME => '.urlrule_task_resume',
    TASK_FILE_LOG    => 'urlrule_task.log',
};


my %TASK_ACTION_MAP= (
    'download'=>'urlrule_get',
    'dump'=>'urlrule_dump',
    'test'=>'urlrule_test',
);
my $TASK_LOGGING    = 1;
my $TASK_ACTION     = 'urlrule_get';
my $TASK_DATABASE   = "DATABASE.URL";
my $HOST_DATABASE = get_rule_dir() . "/HOSTS.URL";
my $TASK_WORKDIR = getcwd();;
my $TASK_FILEHANDLE_LOG;
use MyPlace::Config;
my $Names = MyPlace::Config->new();
$Names->read_plainfile($TASK_DATABASE);


sub MyPlace::URLRule::callback_process_data {
    my($from,$rule,$result) = @_;
    app_message("callback:$from\n");
    &process_data($rule,$result);
}
sub MyPlace::URLRule::callback_process_passdown {
    my($from,$rule,$result) = @_;
    app_message("callback:$from\n");
    &process_passdown($rule,$result);
}

sub process_data {
    my $rule_ref = shift;
    return unless(ref $rule_ref);
    return unless(%{$rule_ref});
    my $result_ref = shift;
    return unless(ref $result_ref);
    return unless(%{$result_ref});

    return unless($result_ref->{data});
    my %rule = %{$rule_ref};
    my %result = %{$result_ref};
    
    my $url=$rule{"url"};
    my $level = $rule{"level"};
    my $action = $rule{"action"};
    my @args = $rule{"args"} ? @{$rule{"args"}} : ();
    my $msghd = "";
    my $count = @{$result{data}};
    app_message($msghd , "Level $level>>","Get $count Lines,performing action $action..\n");
    my ($status,@message) = do_action($result_ref,$action,@args);
    if($status) {
        app_message($msghd,"Level $level>>",@message,"\n");
        return 1;
    }
    else {
        app_warn($msghd,"Level $level>>",@message,"\n");
        return undef;
    }
}


sub process_passdown {
    my $rule_ref = shift;
    return unless(ref $rule_ref);
    return unless(%{$rule_ref});
    my $result_ref = shift;
    return unless(ref $result_ref);
    return unless(%{$result_ref});
    my $msghd="";
    my ($level,$count,@passdown) = make_passdown($rule_ref,$result_ref);
    my $tlevel = $rule_ref->{level};
    if($count) {
        app_message($msghd,"Level $tlevel>>","Get $count rules to pass down to level $tlevel.\n");
    }
    else {
        return undef;
#        app_message($msghd,"Level $level>>","Get nothing to pass.\n");
        return 1;
    }
    for(my $i=0;$i<$count;$i++) {
        my ($dir,@args) = @{$passdown[$i]};
        my $cwd = getcwd();
        if($dir) {
            mkdir $dir unless(-d $dir);
            if(!chdir $dir) {
                app_error($msghd,"Level $tlevel>>","$!\n");
                next;
            }
        }
        app_message($msghd , "Level $tlevel>>","[" . ($i + 1) . "/$count] $args[0]\n");
        $phnd->push(getcwd(),'process_rule',@args);
        chdir $cwd;
    }
    return 1;
}

sub convert_records {
    my ($Hosts,@records) = @_;
    my @r;
    foreach my $record (@records) {
        foreach my $path (@{$record}) {
            my($name,$id,$host) = @{$path};
            next unless($name);
            next unless($id);
            next unless($host);
            my ($url) = $Hosts->propget($host);
            if($url) {
                my ($level) = $Hosts->propget($host,$url);
                my ($id_name,@id_text) = split(/\s*:\s*/,$id);
                $url =~ s/###(?:ID|NAME])###/$id_name/g;
                my $index = 0;
                foreach(@id_text) {
                    $index++;
                    $url =~ s/###TEXT$index###/$_/g;
                }
                push @r,[$name,$id,$host,$url,$level];
            }
            else {
                app_error("HOST $host isn't valid, or not defined in :\n\t$HOST_DATABASE\n");
            }
        }
    }
    return @r;
}

sub action_ECHO {
    my $task = shift;
    my($name,$id,$host,$url,$level) = @{$task};
    $level=0 unless($level);
    app_message("$name/$host [$level]$url\n");
    return;
}


sub do_apply_rule {
    my %rule = %{parse_rule(@_)};
    my $url = $rule{"url"};
    my $domain = $rule{"domain"};
    my $source = $rule{"source"};
    my $level = $rule{"level"};
    my $action = $rule{"action"};
    my @args = $rule{"args"} ? @{$rule{"args"}} : ();
    app_message("For \"$url\"\n");
    app_message("Level $level>>","Found rule: \"$source\"\n");
    app_message("Level $level>>","Applying it ...\n");
    my($status,$result) =  execute_rule(%rule);
    return $status,\%rule,$result;
}

sub action_DUMP {
    my $task = shift;
    my($name,$id,$host,$url,$level) = @{$task};
    my($status,$rule,$result,@msg) = do_apply_rule($url,$level);
    if($status) {
        use Data::Dumper;
        print STDERR Data::Dumper->Dump([$result],['*result']);
        return 1;
    }
    else {
        app_error("Error:",$rule,$result,@msg,"\n");
        return undef;
    }
}
sub action_DOWNLOAD {
    my $task = shift;
    my($name,$id,$host,$url,$level) = @{$task};
    my $cwd = getcwd();
    if(! -d "$name") {
        app_message("Create directory: $name\n");
        mkdir $name;
    }
    if(! -d "$name/$host") {
        app_message("Create directory: $name/$host\n");
        mkdir "$name/$host";
    }
    if(!chdir("$name/$host")) {
        app_error("$!\n");
        return undef;
    }
    if(&process_rule($url,$level,'batchget -M 300 -f')) {
        my $Names = MyPlace::Config->new();
        $Names->read_plainfile($TASK_DATABASE);
        $Names->propset(scalar(localtime),$name,$id,$host,"last");
        print STDERR "Saving $TASK_DATABASE...\n";
        $Names->write_plainfile($TASK_DATABASE);
    }
    chdir $cwd;
    return 1;
}
sub process_rule {
    my($status,$rule,$result,@msg) = do_apply_rule(@_);
    if($status) {
        process_data($rule,$result);
        process_passdown($rule,$result);
        return 1;
    }
    else {
        app_error("Error:",$rule,$result,@msg,"\n");
        return undef;
    }
}
sub log {
    return unless($TASK_FILEHANDLE_LOG);
    print $TASK_FILEHANDLE_LOG scalar(localtime),": ",@_,"\n" if(@_);
}


sub sig_killed {
    app_message("saving remained tasks...\n");
    if($phnd->{lastStack}) {
        $phnd->unshift(@{$phnd->{lastStack}});
    }
    chdir($TASK_WORKDIR) if($TASK_WORKDIR);
    $phnd->saveToFile(TASK_FILE_RESUME);
    app_message($phnd->length," tasks saved to TASK_FILE_RESUME\n");
    &log("Updating aborted!");
    clean_up();
    exit 1;
}


$SIG{INT} = \&sig_killed;
sub init {
        open $TASK_FILEHANDLE_LOG,">>",TASK_FILE_LOG;
        $phnd= MyPlace::ReEnterable->new('main');
};
sub clean_up {
    close TASK_FILEHANDLE_LOG;
    if($Names->{dirty}) {
    }
}

if(@ARGV) {
    my ($action,$query) = @ARGV;
    if($action eq 'DUMP') {
    }
    elsif($action eq 'ECHO') {
    }
    elsif($action eq 'DOWNLOAD') {
    }
    else {
        $query = $action;
        $action = 'DOWNLOAD';
    }
    die("No DATA_FILE(" . $TASK_DATABASE . ") found\n") unless(-r $TASK_DATABASE);
    my $Hosts = MyPlace::Config->new();
    $Hosts->read_plainfile($HOST_DATABASE);
    my @targets =  $Names->query($query);
    if(!@targets) {
        app_error("Nothing match query $query\n");
        exit 1;
    }
    my @records = $Names->get_records(@targets);
    &init;
    my @tasks = convert_records($Hosts,\@records);
    foreach(@tasks) {
        $phnd->push($TASK_WORKDIR,"action_$action",$_);
    }
}
else {
    &init;
    $phnd->loadFromFile(TASK_FILE_RESUME);
}

unless($phnd->length) {
    app_error("Nothing to do!\n");
    exit 0;
}

while(my $tasks = $phnd->length) {
    app_error("[$tasks] tasks remained\n");
    $phnd->run();
}
app_message "All tasks completed.\n";
unlink TASK_FILE_RESUME if(-f TASK_FILE_RESUME);
#&log("Updating completed.");
close TASK_FILEHANDLE_LOG;
exit 0;
