#!/usr/bin/perl -w 
use Cwd qw/getcwd/;
use lib $ENV{XR_PERL_MODULE_DIR};
use MyPlace::URLRule;
use MyPlace::ReEnterable;
use MyPlace::Script::Message;
use Cwd;
use strict;

#use MyPlace::URLRule::HostMap qw/%HOST_MAP get_task valid_hostname add_host get_hosts/;

my $phnd;
use constant {
    TASK_FILE_RESUME => '.urlrule_task_resume',
    TASK_FILE_LOG    => 'urlrule_task.log',
};

my $TASK_LOGGING    = 1;
my $TASK_DATABASE   = "DATABASE.URL";
my $HOST_DATABASE = get_rule_dir() . "/HOSTS.URL";
my $TASK_WORKDIR = getcwd();;
my $TASK_FILEHANDLE_LOG;
use MyPlace::Config;
my $Names = MyPlace::Config->new();
$Names->read_plainfile($TASK_DATABASE);


sub load_rule {
    my $CWD = getcwd;
    my ($status1,$rule,$result) = urlrule_process_args(@_);
    if($status1) {
        my($status2,$pass_count,@passdown)
            = urlrule_process_result($rule,$result);
        if($status2 and $pass_count>0) {
            my $CWD = getcwd;
            foreach(@passdown) {
                my($cwd,@args) = @{$_};
                if(@args) {
                    $phnd->push($CWD,'load_rule',$cwd,@args);
                }
            }
        }
        chdir $CWD;
    }
}

sub convert_records {
    my ($Hosts,@records) = @_;
    my @r;
    foreach my $record (@records) {
        foreach my $path (@{$record}) {
            my($name,$id,$host) = @{$path};
            next unless($name);
            next unless($id);
            next unless($host);
            my ($url) = $Hosts->propget($host);
            if($url) {
                my ($level) = $Hosts->propget($host,$url);
                my ($id_name,@id_text) = split(/\s*:\s*/,$id);
                $url =~ s/###(?:ID|NAME])###/$id_name/g;
                my $index = 0;
                foreach(@id_text) {
                    $index++;
                    $url =~ s/###TEXT$index###/$_/g;
                }
                push @r,[$name,$id,$host,$url,$level];
            }
            else {
                app_error("HOST $host isn't valid, or not defined in :\n\t$HOST_DATABASE\n");
            }
        }
    }
    return @r;
}

sub action_ECHO {
    my $task = shift;
    my($name,$id,$host,$url,$level) = @{$task};
    $level=0 unless($level);
    app_message("$name/$host [$level]$url\n");
    return;
}


sub action_DUMP {
    my $task = shift;
    my($name,$id,$host,$url,$level) = @{$task};
    my($status,$rule,$result,@msg) = urlrule_process_args(undef,$url,$level);
    if($status) {
        use Data::Dumper;
        print STDERR Data::Dumper->Dump([$result],['*result']);
        return 1;
    }
    else {
        app_error("Error:",$rule,$result,@msg,"\n");
        return undef;
    }
}
sub action_DOWNLOAD {
    my $task = shift;
    my($name,$id,$host,$url,$level) = @{$task};
    my $cwd = getcwd();
    if(! -d "$name") {
        app_message("Create directory: $name\n");
        mkdir $name;
    }
    if(! -d "$name/$host") {
        app_message("Create directory: $name/$host\n");
        mkdir "$name/$host";
    }
    if(! -d "$name/$host") {
        app_error("Can't access $name/$host!\n");
        return undef;
    }
    my $Names = MyPlace::Config->new();
    $Names->read_plainfile($TASK_DATABASE);
    $Names->propset(scalar(localtime),$name,$id,$host,"last");
    print STDERR "Saving $TASK_DATABASE...\n";
    $Names->write_plainfile($TASK_DATABASE);
    app_message("Processing $name/$host\n");
    load_rule("$name/$host",$url,$level,'batchget -U -M 300 -f');
    return 1;
}
sub log {
    return unless($TASK_FILEHANDLE_LOG);
    print $TASK_FILEHANDLE_LOG scalar(localtime),": ",@_,"\n" if(@_);
}


sub sig_killed {
    app_message("saving remained tasks...\n");
    if($phnd->{lastStack}) {
        $phnd->unshift(@{$phnd->{lastStack}});
    }
    chdir($TASK_WORKDIR) if($TASK_WORKDIR);
    $phnd->saveToFile(TASK_FILE_RESUME);
    app_message($phnd->length," task(s) saved to " . TASK_FILE_RESUME . "\n");
    &log("Updating aborted!");
    clean_up();
    exit 1;
}


$SIG{INT} = \&sig_killed;
sub init {
        open $TASK_FILEHANDLE_LOG,">>",TASK_FILE_LOG;
        $phnd= MyPlace::ReEnterable->new('main');
};
sub clean_up {
    close TASK_FILEHANDLE_LOG;
    if($Names->{dirty}) {
    }
}

if(@ARGV) {
    die("No DATA_FILE(" . $TASK_DATABASE . ") found\n") unless(-r $TASK_DATABASE);
    my ($action,$query) = @ARGV;
    if($action eq 'DUMP') {
    }
    elsif($action eq 'DOWNLOAD') {
    }
    else {
        $query = $action;
        $action = 'ECHO';
    }
    my $Hosts = MyPlace::Config->new();
    $Hosts->read_plainfile($HOST_DATABASE);
    my @targets =  $Names->query($query);
    if(!@targets) {
        app_error("Nothing match query $query\n");
        exit 1;
    }
    my @records = $Names->get_records(@targets);
    my @tasks = convert_records($Hosts,\@records);
    if($action eq 'DOWNLOAD') {
        &init;
        foreach(@tasks) {
            $phnd->push($TASK_WORKDIR,"action_$action",$_);
        }
    }
    else {
        foreach(@tasks) {
            eval("action_$action(\$_)");
        }
        exit 0;
    }
}
else {
    &init;
    $phnd->loadFromFile(TASK_FILE_RESUME);
}

unless($phnd->length) {
    app_error("Nothing to do!\n");
    exit 0;
}

while(my $tasks = $phnd->length) {
    app_error("[$tasks] tasks remained\n");
    $phnd->run();
}
app_message "All tasks completed.\n";
unlink TASK_FILE_RESUME if(-f TASK_FILE_RESUME);
#&log("Updating completed.");
close TASK_FILEHANDLE_LOG;
exit 0;
